/* parse_pk.c -- parse a dnssec-keygen(8) RSA/MD5 private key
 *
 * Copyright 2007 Dean Scarff
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You
 * may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef HAVE_ARPA_NAMESER_H
#include <arpa/nameser.h>
#endif
#include "rpl_nameser.h"

#include "hope.h"

// BASE 64 DECODING ////////////////////////////////////////////////////

enum
{
	BASE64_ERROR = -1,
	BASE64_PAD = -2
};

static signed char lookup64[128] = {
	// clang-format off
	// 0
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,

	// 16
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,

	// 32
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, 62,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, 63,

	52, 53, 54, 55,
	56, 57, 58, 59,
	60, 61, BASE64_ERROR, BASE64_ERROR,
	BASE64_ERROR, BASE64_PAD, BASE64_ERROR, BASE64_ERROR,

	BASE64_ERROR, 0, 1, 2,
	3, 4, 5, 6,
	7, 8, 9, 10,
	11, 12, 13, 14,

	15, 16, 17, 18,
	19, 20, 21, 22,
	23, 24, 25, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,

	BASE64_ERROR, 26, 27, 28,
	29, 30, 31, 32,
	33, 34, 35, 36,
	37, 38, 39, 40,

	41, 42, 43, 44,
	45, 46, 47, 48,
	49, 50, 51, BASE64_ERROR,
	BASE64_ERROR, BASE64_ERROR, BASE64_ERROR, BASE64_ERROR,
	// clang-format on
};

/* Return the PEM/MIME base-64 symbol `c' mapped to a 6-bit integer.
 * If `c' is a valid symbol, return `BASE64_ERROR'. */
static short
decode64_char(int c)
{
	if (0 > (signed char)c)
		return BASE64_ERROR;
	return lookup64[c];
}

// See parse_pk.h
size_t
decode64(char *dst, const char *str)
{
	char *d = dst;
	while (*str) {
		// 4 base64 symbols yields 3 octets
		uint32_t x = 0;
		for (int i = 0; i < 4; ++i) {
			int c = decode64_char(str[i]);
			hope(BASE64_ERROR != c, "could not parse private key");
			x <<= 6;
			if (BASE64_PAD == c)
				x |= 0x02000000; // flag padding
			else
				x |= c;
		}
		*d++ = (x >> 16) & 0xff;
		if (!(x & 0x80000000)) { // < 2 padding octets
			*d++ = (x >> 8) & 0xff;
			if (!(x & 0x02000000)) // 0 padding octets
				*d++ = x & 0xff;
		}
		str += 4;
	}
	return d - dst;
}

// FIELD PARSING ///////////////////////////////////////////////////////

/* Maximum number of octets in a private key line as generated by
 * dnssec-keygen(8). */
#define DNSSEC_PRIVATE_MAX_LINE (NS_MD5RSA_MAX_BASE64 + 64)

static const char *known_fields[] = { "Modulus", "PublicExponent",
	"PrivateExponent", "Prime1", "Prime2", "Exponent1", "Exponent2",
	"Coefficient", NULL };

// See parse_pk.h
void
parse_pk_file(FILE *fp, void (*cb)(unsigned, const char *))
{
	char *buf = xmalloc(DNSSEC_PRIVATE_MAX_LINE);

	while (!feof(fp)) {
		fgets(buf, DNSSEC_PRIVATE_MAX_LINE, fp);
		hope2(!ferror(fp), "reading private key", strerror(errno));
		char *colon = strchr(buf, ':');
		char *nl = strchr(buf, '\n');
		if (!colon || ' ' != colon[1])
			break;
		if (DNSSEC_PRIVATE_MAX_LINE - 2 <= colon - buf)
			break;
		*colon = 0;
		if (nl)
			*nl = 0;
		const char **kf = known_fields;
		while (NULL != *kf) {
			if (0 == strcmp(*kf, buf)) {
				(*cb)(kf - known_fields, colon + 2);
				break;
			}
			++kf;
		}
	}
	free(buf);
}
