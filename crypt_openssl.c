/* crypt_openssl.c -- OpenSSL crypto interface
 *
 * Copyright 2007 Dean Scarff
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You
 * may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
#include <stdint.h>

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/md5.h>
#include <openssl/objects.h>
#include <openssl/rsa.h>

#include "hope.h"
#include "parse_pk.h"

/* Footprint in host byte-order. */
static uint16_t footprint;

/* OpenSSL key handle. */
static RSA *rsa_key;

// See crypt.h
void
crypt_init()
{
	ERR_load_crypto_strings();
}

// See crypt.h
void
crypt_finish()
{
	RSA_free(rsa_key);
}

/* Decode and store `data' into `rsa_key' if it `field' is a secret
 * key parameter required for signing. */
static void
load_line(enum pk_field_key field, const char *data)
{
	unsigned char *buf = xmalloc(decode64_length(data));
	size_t octet_count = decode64((char *)buf, data);
	BIGNUM *bn = BN_bin2bn(buf, octet_count, NULL);
	free(buf);
	switch (field) {
	case PKFK_MODULUS:
		rsa_key->n = bn;
		footprint = (uint16_t)(buf[octet_count - 3]) << 8;
		footprint |= buf[octet_count - 2];
		break;
	case PKFK_PUBLIC_EXPONENT:
		rsa_key->e = bn;
		break;
	case PKFK_PRIVATE_EXPONENT:
		rsa_key->d = bn;
		break;
	case PKFK_PRIME1:
		rsa_key->p = bn;
		break;
	case PKFK_PRIME2:
		rsa_key->q = bn;
		break;
	case PKFK_EXPONENT1:
		// according to RSA_check_key, a key generated by
		// dnssec-keygen contains bad exponents
		// rsa_key->dmp1 = bn;
		break;
	case PKFK_EXPONENT2:
		// rsa_key->dmq1 = bn;
		break;
	case PKFK_COEFFICIENT:
		rsa_key->iqmp = bn;
		break;
	default:
		break;
	}
}

// See crypt.h
void
crypt_load_key(FILE *privkey)
{
	rsa_key = RSA_new();
	assert(rsa_key);

	parse_pk_file(privkey, &load_line);

	if (1 != RSA_check_key(rsa_key)) {
		unsigned long err = ERR_get_error();
		nohope2("loading private key", ERR_error_string(err, NULL));
	}
}

// See crypt.h
uint16_t
crypt_footprint()
{
	return footprint;
}

// See crypt.h
size_t
crypt_sign_length()
{
	return (size_t)RSA_size(rsa_key);
}

enum
{
	MD5_LENGTH = 16 // digest length in octets
};

// See crypt.h
char *
crypt_sign(char *dst, const char *src, size_t length)
{
	int err;
	unsigned char digest[MD5_LENGTH];
	MD5((const unsigned char *)src, length, digest);

	unsigned siglen;
	err = RSA_sign(NID_md5, digest, MD5_LENGTH, (unsigned char *)dst,
	    &siglen, rsa_key);
	hope(1 == err, "could not write signature");
	return dst + siglen;
}
